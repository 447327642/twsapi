
twsapi for Interactive Brokers TWS
==================================


This twsapi is almost identical to the original IB C++ posix api. It contains
several bugfixes, usage improvements and it's using the autotools build system.
For more details read "Changes of original IB API" below.

Check out the latest version at https://github.com/rudimeier/twsapi




Installation
------------

 Building from source requires a c++ compiler (tested with gcc/g++).
 Windows has been successfully tested using cygwin.

 ./configure
 make
 make install

 (Within git repo type "autoreconf -fi" before.)




Repository layout
-----------------

Beside the usual master branch I keep two important branches:
 - ib_orig: the original IB API code from upstream
 - ib_orig_plus: the original IB API plus autotools build chain

Both are used to commit upstream updates to be merged into master. 




Changes of original IB API
--------------------------

Here I point out some of the most important things about our modified TWS API.
(This documentation may not be entirely complete.)


Generally the socket error handling is stable and reliable now. Error message
callbacks with code SOCKET_EXCEPTION are using standard message strings
(errno/strerror).

Hostnames will be resolved.


eConnect():
 1. It's blocking and returns either connected or disconnected.
 2. It may callback informative error messages only. No more checking of
    regular messages.
 3. If any callback is fired then state will still be  "disconnected".
    Return false in this case. There are no "positive callbacks".
 4. There can be multiple callbacks, for example "UPDATE_TWS" and then
    "CONNECT_FAIL" but 2. and 3. are always in place! The client programmer
    does not need to do any cleanup actions on these callbacks.
 5. Before returning false CONNECT_FAIL with descriptive message will be fired
    fore sure.


onReceive():
 1. Any callback (except connectionClosed()) will be fired in state connected,
    even if we are going to be disconnected.
 2. Before connectionClosed() is fired we will get a "SOCKET_EXCEPTION"
    callback still in state conneted.


all other req*() functions:
 1. If called while disconneted then it sends a NOT_CONNECTED callback (we
    could have known before).
 2. On error it sends a SOCKET_EXCEPTION (still in state connected) and
    then connectionClosed() (already disconnected state).
 3. Another possible callback is UPDATE_TWS (does not disconnect us).



Thus we know about callbacks:
 1. Within connectionClosed() we are disconnected for sure.
 2. Within error() we could be disconneted only if code is CONNECT_FAIL,
    UPDATE_TWS or NOT_CONNECTED.
 3. In any other case callbacks will be received in state connected.


TODO: In oppsite to the statements above SOCKET_EXCEPTION may still be fired in
      state connected if onReceive() or onSend() are called while disconnected
      (we could have known before). To be safe we could return early and send
      NOT_CONNECTED.


API internal implementation notes:

bufferedRead()
 1. Behaves like ::recv() regarding errno and return value:
      -1: error, errno set
       0: EOF, disconnectd
      >0: success




License
-------

  95% of the source code comes from Interactive Brokers. Please read there
  about any licensing issues:
  http://www.interactivebrokers.com




Contact Information
-------------------

  If you have questions, bug reports, patches etc., contact
  Ruediger Meier <sweet_f_a@gmx.de> (in English or German).

